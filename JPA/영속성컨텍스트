영속성 컨텍스트는 엔터티를 영구저장하는 환경이다. 애플리캐이션과 데이터베이스의 중간에 있는 가상의 영역.
JPA는 스레드가 하나 생성될 때 마다(매 요청마다) EntityManagerFactory에서 EntityManager를 생성한다

EntityManager가 생성될 때 만들어진다.

Entity 의 LifeCycle
- 비영속(new/transient) : 영속성컨텍스트와 전혀 관계 없는 상태
- 영속(managed) : 영속성컨텍스트에 저장된 상태
- 준영속(detached) : 영속성컨텍스트에서 관리되다가 분리된 상태
- 삭제(remove) :삭제된 상태

식별자 값(Id)
영속성 컨텍스트는 객체를 식별자 값으로 구분한다. 그래서 영속 상태는 반드시 식별자 값이 포함되어있어야한다.

데이터 반영
flush(동기화) 호출 시 반영.
commit() 에도 flush()가 포함되어있음.


장점 
1. 1차캐시
2. 동일성 보장
3. 트랜잭션을 지원하는 쓰기지연
4. 변경감지
5. 지연로딩

1. 1차캐시( 효율적으로 리소스를 사용하기위해)
영속성 컨텍스트 내에 있는 캐시. 식별값을 키로 가지고있는 HashMap으로 구성. Entity를 value로 가지고있음.
DB 조회 후 1차캐시에 Entity를 저장하고 같은 영속성 컨텍스트 안에서  해당객체를 다시 조회할 때 1차캐시를 우선 검색.
없으면 DB조회 후 1차캐시에 저장후 반환.

2. 동일성 보장
두 객체가 서로다른 메모리 주소를 할당받아도 참조하는 Entity의 식별값이 같다면 동일한 객체. 객체의 동일성을 보장.

3. 쓰기지연
영속성 컨텍스트 내부 쿼리저장소에 모아둔 쿼리를 커밋시점에 한번에 보낸다.

4. 변경감지
EntityManager가 flush를 호출하고, Entity와 스탭샷을 비교해서 변경된 Entity를 찾는다.
변경된 Entity가 있으면 수정쿼리를 생성해서 쿼리저장소에 쿼리를 저장하고 커밋시점

Entity Manager 내부에서 flush -> Entity , 스냅샷 비교 후 변경감지 -> 쿼리생성 -> 쓰기지연 SQL 저장소에 쿼리저장 -> 쓰기지연 flush() -> 트랜잭션 flush() (DB반영)

1차캐시.. 캐시는 언제봐도 참 좋은녀석같다. Cash도 그렇고


정리를 하자면 영속성 컨텍스트 구조는

-------------영속성컨텍스트 --------------

1차캐시 영역      쓰기지연 내부sql저장소

-----------------------------------------

정도로 되어있고, EntityManagerFactory 로부터 생성된 Entity Manager 가 영속성컨텍스트를 관리한다.
리소스를 효율적으로 관리하기위해 1차캐시를 활용하고있고, 이는 HashMap 형태로 key : @Id , value : Entity 로 이루어져있다.
그렇기 때문에 같은 Id 값을 가진 Entity에대해 동시성을 보장한다. 
그리고 영속성 컨텍스트는 flush()를 호출함으로써 DB에 변경된 데이터를 반영하는데, 이는 1차적으로 쓰기지연 내부 sql저장소에 쿼리를 저장했다가 
트랜잭션이 커밋되는 순간 반영된다. 글고 스냅샷(최초 Entity상태)을 이용해 변경감지를 하고 proxy객체를 이용해 지연로딩을 한다.

끄읏!
